{"version":3,"file":"workbox-strategies.prod.js","sources":["../_version.js","../StrategyHandler.js","../Strategy.js","../plugins/cacheOkAndOpaquePlugin.js","../CacheFirst.js","../CacheOnly.js","../NetworkFirst.js","../NetworkOnly.js","../StaleWhileRevalidate.js"],"sourcesContent":["\"use strict\";\r\n// @ts-ignore\r\ntry {\r\n    self['workbox:strategies:6.1.5'] && _();\r\n}\r\ncatch (e) { }\r\n","/*\r\n  Copyright 2020 Google LLC\r\n\r\n  Use of this source code is governed by an MIT-style\r\n  license that can be found in the LICENSE file or at\r\n  https://opensource.org/licenses/MIT.\r\n*/\r\nimport { assert } from 'workbox-core/_private/assert.js';\r\nimport { cacheMatchIgnoreParams } from 'workbox-core/_private/cacheMatchIgnoreParams.js';\r\nimport { Deferred } from 'workbox-core/_private/Deferred.js';\r\nimport { executeQuotaErrorCallbacks } from 'workbox-core/_private/executeQuotaErrorCallbacks.js';\r\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\r\nimport { logger } from 'workbox-core/_private/logger.js';\r\nimport { timeout } from 'workbox-core/_private/timeout.js';\r\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\r\nimport './_version.js';\r\nfunction toRequest(input) {\r\n    return (typeof input === 'string') ? new Request(input) : input;\r\n}\r\n/**\r\n * A class created every time a Strategy instance instance calls\r\n * [handle()]{@link module:workbox-strategies.Strategy~handle} or\r\n * [handleAll()]{@link module:workbox-strategies.Strategy~handleAll} that wraps all fetch and\r\n * cache actions around plugin callbacks and keeps track of when the strategy\r\n * is \"done\" (i.e. all added `event.waitUntil()` promises have resolved).\r\n *\r\n * @memberof module:workbox-strategies\r\n */\r\nclass StrategyHandler {\r\n    /**\r\n     * Creates a new instance associated with the passed strategy and event\r\n     * that's handling the request.\r\n     *\r\n     * The constructor also initializes the state that will be passed to each of\r\n     * the plugins handling this request.\r\n     *\r\n     * @param {module:workbox-strategies.Strategy} strategy\r\n     * @param {Object} options\r\n     * @param {Request|string} options.request A request to run this strategy for.\r\n     * @param {ExtendableEvent} options.event The event associated with the\r\n     *     request.\r\n     * @param {URL} [options.url]\r\n     * @param {*} [options.params]\r\n     *     [match callback]{@link module:workbox-routing~matchCallback},\r\n     *     (if applicable).\r\n     */\r\n    constructor(strategy, options) {\r\n        this._cacheKeys = {};\r\n        /**\r\n         * The request the strategy is performing (passed to the strategy's\r\n         * `handle()` or `handleAll()` method).\r\n         * @name request\r\n         * @instance\r\n         * @type {Request}\r\n         * @memberof module:workbox-strategies.StrategyHandler\r\n         */\r\n        /**\r\n         * The event associated with this request.\r\n         * @name event\r\n         * @instance\r\n         * @type {ExtendableEvent}\r\n         * @memberof module:workbox-strategies.StrategyHandler\r\n         */\r\n        /**\r\n         * A `URL` instance of `request.url` (if passed to the strategy's\r\n         * `handle()` or `handleAll()` method).\r\n         * Note: the `url` param will be present if the strategy was invoked\r\n         * from a workbox `Route` object.\r\n         * @name url\r\n         * @instance\r\n         * @type {URL|undefined}\r\n         * @memberof module:workbox-strategies.StrategyHandler\r\n         */\r\n        /**\r\n         * A `param` value (if passed to the strategy's\r\n         * `handle()` or `handleAll()` method).\r\n         * Note: the `param` param will be present if the strategy was invoked\r\n         * from a workbox `Route` object and the\r\n         * [match callback]{@link module:workbox-routing~matchCallback} returned\r\n         * a truthy value (it will be that value).\r\n         * @name params\r\n         * @instance\r\n         * @type {*|undefined}\r\n         * @memberof module:workbox-strategies.StrategyHandler\r\n         */\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            assert.isInstance(options.event, ExtendableEvent, {\r\n                moduleName: 'workbox-strategies',\r\n                className: 'StrategyHandler',\r\n                funcName: 'constructor',\r\n                paramName: 'options.event',\r\n            });\r\n        }\r\n        Object.assign(this, options);\r\n        this.event = options.event;\r\n        this._strategy = strategy;\r\n        this._handlerDeferred = new Deferred();\r\n        this._extendLifetimePromises = [];\r\n        // Copy the plugins list (since it's mutable on the strategy),\r\n        // so any mutations don't affect this handler instance.\r\n        this._plugins = [...strategy.plugins];\r\n        this._pluginStateMap = new Map();\r\n        for (const plugin of this._plugins) {\r\n            this._pluginStateMap.set(plugin, {});\r\n        }\r\n        this.event.waitUntil(this._handlerDeferred.promise);\r\n    }\r\n    /**\r\n     * Fetches a given request (and invokes any applicable plugin callback\r\n     * methods) using the `fetchOptions` (for non-navigation requests) and\r\n     * `plugins` defined on the `Strategy` object.\r\n     *\r\n     * The following plugin lifecycle methods are invoked when using this method:\r\n     * - `requestWillFetch()`\r\n     * - `fetchDidSucceed()`\r\n     * - `fetchDidFail()`\r\n     *\r\n     * @param {Request|string} input The URL or request to fetch.\r\n     * @return {Promise<Response>}\r\n     */\r\n    async fetch(input) {\r\n        const { event } = this;\r\n        let request = toRequest(input);\r\n        if (request.mode === 'navigate' &&\r\n            event instanceof FetchEvent &&\r\n            event.preloadResponse) {\r\n            const possiblePreloadResponse = await event.preloadResponse;\r\n            if (possiblePreloadResponse) {\r\n                if (process.env.NODE_ENV !== 'production') {\r\n                    logger.log(`Using a preloaded navigation response for ` +\r\n                        `'${getFriendlyURL(request.url)}'`);\r\n                }\r\n                return possiblePreloadResponse;\r\n            }\r\n        }\r\n        // If there is a fetchDidFail plugin, we need to save a clone of the\r\n        // original request before it's either modified by a requestWillFetch\r\n        // plugin or before the original request's body is consumed via fetch().\r\n        const originalRequest = this.hasCallback('fetchDidFail') ?\r\n            request.clone() : null;\r\n        try {\r\n            for (const cb of this.iterateCallbacks('requestWillFetch')) {\r\n                request = await cb({ request: request.clone(), event });\r\n            }\r\n        }\r\n        catch (err) {\r\n            throw new WorkboxError('plugin-error-request-will-fetch', {\r\n                thrownError: err,\r\n            });\r\n        }\r\n        // The request can be altered by plugins with `requestWillFetch` making\r\n        // the original request (most likely from a `fetch` event) different\r\n        // from the Request we make. Pass both to `fetchDidFail` to aid debugging.\r\n        const pluginFilteredRequest = request.clone();\r\n        try {\r\n            let fetchResponse;\r\n            // See https://github.com/GoogleChrome/workbox/issues/1796\r\n            fetchResponse = await fetch(request, request.mode === 'navigate' ?\r\n                undefined : this._strategy.fetchOptions);\r\n            if (process.env.NODE_ENV !== 'production') {\r\n                logger.debug(`Network request for ` +\r\n                    `'${getFriendlyURL(request.url)}' returned a response with ` +\r\n                    `status '${fetchResponse.status}'.`);\r\n            }\r\n            for (const callback of this.iterateCallbacks('fetchDidSucceed')) {\r\n                fetchResponse = await callback({\r\n                    event,\r\n                    request: pluginFilteredRequest,\r\n                    response: fetchResponse,\r\n                });\r\n            }\r\n            return fetchResponse;\r\n        }\r\n        catch (error) {\r\n            if (process.env.NODE_ENV !== 'production') {\r\n                logger.log(`Network request for ` +\r\n                    `'${getFriendlyURL(request.url)}' threw an error.`, error);\r\n            }\r\n            // `originalRequest` will only exist if a `fetchDidFail` callback\r\n            // is being used (see above).\r\n            if (originalRequest) {\r\n                await this.runCallbacks('fetchDidFail', {\r\n                    error,\r\n                    event,\r\n                    originalRequest: originalRequest.clone(),\r\n                    request: pluginFilteredRequest.clone(),\r\n                });\r\n            }\r\n            throw error;\r\n        }\r\n    }\r\n    /**\r\n     * Calls `this.fetch()` and (in the background) runs `this.cachePut()` on\r\n     * the response generated by `this.fetch()`.\r\n     *\r\n     * The call to `this.cachePut()` automatically invokes `this.waitUntil()`,\r\n     * so you do not have to manually call `waitUntil()` on the event.\r\n     *\r\n     * @param {Request|string} input The request or URL to fetch and cache.\r\n     * @return {Promise<Response>}\r\n     */\r\n    async fetchAndCachePut(input) {\r\n        const response = await this.fetch(input);\r\n        const responseClone = response.clone();\r\n        this.waitUntil(this.cachePut(input, responseClone));\r\n        return response;\r\n    }\r\n    /**\r\n     * Matches a request from the cache (and invokes any applicable plugin\r\n     * callback methods) using the `cacheName`, `matchOptions`, and `plugins`\r\n     * defined on the strategy object.\r\n     *\r\n     * The following plugin lifecycle methods are invoked when using this method:\r\n     * - cacheKeyWillByUsed()\r\n     * - cachedResponseWillByUsed()\r\n     *\r\n     * @param {Request|string} key The Request or URL to use as the cache key.\r\n     * @return {Promise<Response|undefined>} A matching response, if found.\r\n     */\r\n    async cacheMatch(key) {\r\n        const request = toRequest(key);\r\n        let cachedResponse;\r\n        const { cacheName, matchOptions } = this._strategy;\r\n        const effectiveRequest = await this.getCacheKey(request, 'read');\r\n        const multiMatchOptions = { ...matchOptions, ...{ cacheName } };\r\n        cachedResponse = await caches.match(effectiveRequest, multiMatchOptions);\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            if (cachedResponse) {\r\n                logger.debug(`Found a cached response in '${cacheName}'.`);\r\n            }\r\n            else {\r\n                logger.debug(`No cached response found in '${cacheName}'.`);\r\n            }\r\n        }\r\n        for (const callback of this.iterateCallbacks('cachedResponseWillBeUsed')) {\r\n            cachedResponse = (await callback({\r\n                cacheName,\r\n                matchOptions,\r\n                cachedResponse,\r\n                request: effectiveRequest,\r\n                event: this.event,\r\n            })) || undefined;\r\n        }\r\n        return cachedResponse;\r\n    }\r\n    /**\r\n     * Puts a request/response pair in the cache (and invokes any applicable\r\n     * plugin callback methods) using the `cacheName` and `plugins` defined on\r\n     * the strategy object.\r\n     *\r\n     * The following plugin lifecycle methods are invoked when using this method:\r\n     * - cacheKeyWillByUsed()\r\n     * - cacheWillUpdate()\r\n     * - cacheDidUpdate()\r\n     *\r\n     * @param {Request|string} key The request or URL to use as the cache key.\r\n     * @param {Response} response The response to cache.\r\n     * @return {Promise<boolean>} `false` if a cacheWillUpdate caused the response\r\n     * not be cached, and `true` otherwise.\r\n     */\r\n    async cachePut(key, response) {\r\n        const request = toRequest(key);\r\n        // Run in the next task to avoid blocking other cache reads.\r\n        // https://github.com/w3c/ServiceWorker/issues/1397\r\n        await timeout(0);\r\n        const effectiveRequest = await this.getCacheKey(request, 'write');\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            if (effectiveRequest.method && effectiveRequest.method !== 'GET') {\r\n                throw new WorkboxError('attempt-to-cache-non-get-request', {\r\n                    url: getFriendlyURL(effectiveRequest.url),\r\n                    method: effectiveRequest.method,\r\n                });\r\n            }\r\n        }\r\n        if (!response) {\r\n            if (process.env.NODE_ENV !== 'production') {\r\n                logger.error(`Cannot cache non-existent response for ` +\r\n                    `'${getFriendlyURL(effectiveRequest.url)}'.`);\r\n            }\r\n            throw new WorkboxError('cache-put-with-no-response', {\r\n                url: getFriendlyURL(effectiveRequest.url),\r\n            });\r\n        }\r\n        const responseToCache = await this._ensureResponseSafeToCache(response);\r\n        if (!responseToCache) {\r\n            if (process.env.NODE_ENV !== 'production') {\r\n                logger.debug(`Response '${getFriendlyURL(effectiveRequest.url)}' ` +\r\n                    `will not be cached.`, responseToCache);\r\n            }\r\n            return false;\r\n        }\r\n        const { cacheName, matchOptions } = this._strategy;\r\n        const cache = await self.caches.open(cacheName);\r\n        const hasCacheUpdateCallback = this.hasCallback('cacheDidUpdate');\r\n        const oldResponse = hasCacheUpdateCallback ? await cacheMatchIgnoreParams(\r\n        // TODO(philipwalton): the `__WB_REVISION__` param is a precaching\r\n        // feature. Consider into ways to only add this behavior if using\r\n        // precaching.\r\n        cache, effectiveRequest.clone(), ['__WB_REVISION__'], matchOptions) :\r\n            null;\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            logger.debug(`Updating the '${cacheName}' cache with a new Response ` +\r\n                `for ${getFriendlyURL(effectiveRequest.url)}.`);\r\n        }\r\n        try {\r\n            await cache.put(effectiveRequest, hasCacheUpdateCallback ?\r\n                responseToCache.clone() : responseToCache);\r\n        }\r\n        catch (error) {\r\n            // See https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-QuotaExceededError\r\n            if (error.name === 'QuotaExceededError') {\r\n                await executeQuotaErrorCallbacks();\r\n            }\r\n            throw error;\r\n        }\r\n        for (const callback of this.iterateCallbacks('cacheDidUpdate')) {\r\n            await callback({\r\n                cacheName,\r\n                oldResponse,\r\n                newResponse: responseToCache.clone(),\r\n                request: effectiveRequest,\r\n                event: this.event,\r\n            });\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Checks the list of plugins for the `cacheKeyWillBeUsed` callback, and\r\n     * executes any of those callbacks found in sequence. The final `Request`\r\n     * object returned by the last plugin is treated as the cache key for cache\r\n     * reads and/or writes. If no `cacheKeyWillBeUsed` plugin callbacks have\r\n     * been registered, the passed request is returned unmodified\r\n     *\r\n     * @param {Request} request\r\n     * @param {string} mode\r\n     * @return {Promise<Request>}\r\n     */\r\n    async getCacheKey(request, mode) {\r\n        if (!this._cacheKeys[mode]) {\r\n            let effectiveRequest = request;\r\n            for (const callback of this.iterateCallbacks('cacheKeyWillBeUsed')) {\r\n                effectiveRequest = toRequest(await callback({\r\n                    mode,\r\n                    request: effectiveRequest,\r\n                    event: this.event,\r\n                    params: this.params,\r\n                }));\r\n            }\r\n            this._cacheKeys[mode] = effectiveRequest;\r\n        }\r\n        return this._cacheKeys[mode];\r\n    }\r\n    /**\r\n     * Returns true if the strategy has at least one plugin with the given\r\n     * callback.\r\n     *\r\n     * @param {string} name The name of the callback to check for.\r\n     * @return {boolean}\r\n     */\r\n    hasCallback(name) {\r\n        for (const plugin of this._strategy.plugins) {\r\n            if (name in plugin) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * Runs all plugin callbacks matching the given name, in order, passing the\r\n     * given param object (merged ith the current plugin state) as the only\r\n     * argument.\r\n     *\r\n     * Note: since this method runs all plugins, it's not suitable for cases\r\n     * where the return value of a callback needs to be applied prior to calling\r\n     * the next callback. See\r\n     * [`iterateCallbacks()`]{@link module:workbox-strategies.StrategyHandler#iterateCallbacks}\r\n     * below for how to handle that case.\r\n     *\r\n     * @param {string} name The name of the callback to run within each plugin.\r\n     * @param {Object} param The object to pass as the first (and only) param\r\n     *     when executing each callback. This object will be merged with the\r\n     *     current plugin state prior to callback execution.\r\n     */\r\n    async runCallbacks(name, param) {\r\n        for (const callback of this.iterateCallbacks(name)) {\r\n            // TODO(philipwalton): not sure why `any` is needed. It seems like\r\n            // this should work with `as WorkboxPluginCallbackParam[C]`.\r\n            await callback(param);\r\n        }\r\n    }\r\n    /**\r\n     * Accepts a callback and returns an iterable of matching plugin callbacks,\r\n     * where each callback is wrapped with the current handler state (i.e. when\r\n     * you call each callback, whatever object parameter you pass it will\r\n     * be merged with the plugin's current state).\r\n     *\r\n     * @param {string} name The name fo the callback to run\r\n     * @return {Array<Function>}\r\n     */\r\n    *iterateCallbacks(name) {\r\n        for (const plugin of this._strategy.plugins) {\r\n            if (typeof plugin[name] === 'function') {\r\n                const state = this._pluginStateMap.get(plugin);\r\n                const statefulCallback = (param) => {\r\n                    const statefulParam = { ...param, state };\r\n                    // TODO(philipwalton): not sure why `any` is needed. It seems like\r\n                    // this should work with `as WorkboxPluginCallbackParam[C]`.\r\n                    return plugin[name](statefulParam);\r\n                };\r\n                yield statefulCallback;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Adds a promise to the\r\n     * [extend lifetime promises]{@link https://w3c.github.io/ServiceWorker/#extendableevent-extend-lifetime-promises}\r\n     * of the event event associated with the request being handled (usually a\r\n     * `FetchEvent`).\r\n     *\r\n     * Note: you can await\r\n     * [`doneWaiting()`]{@link module:workbox-strategies.StrategyHandler~doneWaiting}\r\n     * to know when all added promises have settled.\r\n     *\r\n     * @param {Promise} promise A promise to add to the extend lifetime promises\r\n     *     of the event that triggered the request.\r\n     */\r\n    waitUntil(promise) {\r\n        this._extendLifetimePromises.push(promise);\r\n        return promise;\r\n    }\r\n    /**\r\n     * Returns a promise that resolves once all promises passed to\r\n     * [`waitUntil()`]{@link module:workbox-strategies.StrategyHandler~waitUntil}\r\n     * have settled.\r\n     *\r\n     * Note: any work done after `doneWaiting()` settles should be manually\r\n     * passed to an event's `waitUntil()` method (not this handler's\r\n     * `waitUntil()` method), otherwise the service worker thread my be killed\r\n     * prior to your work completing.\r\n     */\r\n    async doneWaiting() {\r\n        let promise;\r\n        while (promise = this._extendLifetimePromises.shift()) {\r\n            await promise;\r\n        }\r\n    }\r\n    /**\r\n     * Stops running the strategy and immediately resolves any pending\r\n     * `waitUntil()` promises.\r\n     */\r\n    destroy() {\r\n        this._handlerDeferred.resolve();\r\n    }\r\n    /**\r\n     * This method will call cacheWillUpdate on the available plugins (or use\r\n     * status === 200) to determine if the Response is safe and valid to cache.\r\n     *\r\n     * @param {Request} options.request\r\n     * @param {Response} options.response\r\n     * @return {Promise<Response|undefined>}\r\n     *\r\n     * @private\r\n     */\r\n    async _ensureResponseSafeToCache(response) {\r\n        let responseToCache = response;\r\n        let pluginsUsed = false;\r\n        for (const callback of this.iterateCallbacks('cacheWillUpdate')) {\r\n            responseToCache = (await callback({\r\n                request: this.request,\r\n                response: responseToCache,\r\n                event: this.event,\r\n            })) || undefined;\r\n            pluginsUsed = true;\r\n            if (!responseToCache) {\r\n                break;\r\n            }\r\n        }\r\n        if (!pluginsUsed) {\r\n            if (responseToCache && responseToCache.status !== 200) {\r\n                responseToCache = undefined;\r\n            }\r\n            if (process.env.NODE_ENV !== 'production') {\r\n                if (responseToCache) {\r\n                    if (responseToCache.status !== 200) {\r\n                        if (responseToCache.status === 0) {\r\n                            logger.warn(`The response for '${this.request.url}' ` +\r\n                                `is an opaque response. The caching strategy that you're ` +\r\n                                `using will not cache opaque responses by default.`);\r\n                        }\r\n                        else {\r\n                            logger.debug(`The response for '${this.request.url}' ` +\r\n                                `returned a status code of '${response.status}' and won't ` +\r\n                                `be cached as a result.`);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return responseToCache;\r\n    }\r\n}\r\nexport { StrategyHandler };\r\n","/*\r\n  Copyright 2020 Google LLC\r\n\r\n  Use of this source code is governed by an MIT-style\r\n  license that can be found in the LICENSE file or at\r\n  https://opensource.org/licenses/MIT.\r\n*/\r\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\r\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\r\nimport { logger } from 'workbox-core/_private/logger.js';\r\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\r\nimport { StrategyHandler } from './StrategyHandler.js';\r\nimport './_version.js';\r\n/**\r\n * An abstract base class that all other strategy classes must extend from:\r\n *\r\n * @memberof module:workbox-strategies\r\n */\r\nclass Strategy {\r\n    /**\r\n     * Creates a new instance of the strategy and sets all documented option\r\n     * properties as public instance properties.\r\n     *\r\n     * Note: if a custom strategy class extends the base Strategy class and does\r\n     * not need more than these properties, it does not need to define its own\r\n     * constructor.\r\n     *\r\n     * @param {Object} [options]\r\n     * @param {string} [options.cacheName] Cache name to store and retrieve\r\n     * requests. Defaults to the cache names provided by\r\n     * [workbox-core]{@link module:workbox-core.cacheNames}.\r\n     * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\r\n     * to use in conjunction with this caching strategy.\r\n     * @param {Object} [options.fetchOptions] Values passed along to the\r\n     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\r\n     * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)\r\n     * `fetch()` requests made by this strategy.\r\n     * @param {Object} [options.matchOptions] The\r\n     * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}\r\n     * for any `cache.match()` or `cache.put()` calls made by this strategy.\r\n     */\r\n    constructor(options = {}) {\r\n        /**\r\n         * Cache name to store and retrieve\r\n         * requests. Defaults to the cache names provided by\r\n         * [workbox-core]{@link module:workbox-core.cacheNames}.\r\n         *\r\n         * @type {string}\r\n         */\r\n        this.cacheName = cacheNames.getRuntimeName(options.cacheName);\r\n        /**\r\n         * The list\r\n         * [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\r\n         * used by this strategy.\r\n         *\r\n         * @type {Array<Object>}\r\n         */\r\n        this.plugins = options.plugins || [];\r\n        /**\r\n         * Values passed along to the\r\n         * [`init`]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters}\r\n         * of all fetch() requests made by this strategy.\r\n         *\r\n         * @type {Object}\r\n         */\r\n        this.fetchOptions = options.fetchOptions;\r\n        /**\r\n         * The\r\n         * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}\r\n         * for any `cache.match()` or `cache.put()` calls made by this strategy.\r\n         *\r\n         * @type {Object}\r\n         */\r\n        this.matchOptions = options.matchOptions;\r\n    }\r\n    /**\r\n     * Perform a request strategy and returns a `Promise` that will resolve with\r\n     * a `Response`, invoking all relevant plugin callbacks.\r\n     *\r\n     * When a strategy instance is registered with a Workbox\r\n     * [route]{@link module:workbox-routing.Route}, this method is automatically\r\n     * called when the route matches.\r\n     *\r\n     * Alternatively, this method can be used in a standalone `FetchEvent`\r\n     * listener by passing it to `event.respondWith()`.\r\n     *\r\n     * @param {FetchEvent|Object} options A `FetchEvent` or an object with the\r\n     *     properties listed below.\r\n     * @param {Request|string} options.request A request to run this strategy for.\r\n     * @param {ExtendableEvent} options.event The event associated with the\r\n     *     request.\r\n     * @param {URL} [options.url]\r\n     * @param {*} [options.params]\r\n     */\r\n    handle(options) {\r\n        const [responseDone] = this.handleAll(options);\r\n        return responseDone;\r\n    }\r\n    /**\r\n     * Similar to [`handle()`]{@link module:workbox-strategies.Strategy~handle}, but\r\n     * instead of just returning a `Promise` that resolves to a `Response` it\r\n     * it will return an tuple of [response, done] promises, where the former\r\n     * (`response`) is equivalent to what `handle()` returns, and the latter is a\r\n     * Promise that will resolve once any promises that were added to\r\n     * `event.waitUntil()` as part of performing the strategy have completed.\r\n     *\r\n     * You can await the `done` promise to ensure any extra work performed by\r\n     * the strategy (usually caching responses) completes successfully.\r\n     *\r\n     * @param {FetchEvent|Object} options A `FetchEvent` or an object with the\r\n     *     properties listed below.\r\n     * @param {Request|string} options.request A request to run this strategy for.\r\n     * @param {ExtendableEvent} options.event The event associated with the\r\n     *     request.\r\n     * @param {URL} [options.url]\r\n     * @param {*} [options.params]\r\n     * @return {Array<Promise>} A tuple of [response, done]\r\n     *     promises that can be used to determine when the response resolves as\r\n     *     well as when the handler has completed all its work.\r\n     */\r\n    handleAll(options) {\r\n        // Allow for flexible options to be passed.\r\n        if (options instanceof FetchEvent) {\r\n            options = {\r\n                event: options,\r\n                request: options.request,\r\n            };\r\n        }\r\n        const event = options.event;\r\n        const request = typeof options.request === 'string' ?\r\n            new Request(options.request) :\r\n            options.request;\r\n        const params = 'params' in options ? options.params : undefined;\r\n        const handler = new StrategyHandler(this, { event, request, params });\r\n        const responseDone = this._getResponse(handler, request, event);\r\n        const handlerDone = this._awaitComplete(responseDone, handler, request, event);\r\n        // Return an array of promises, suitable for use with Promise.all().\r\n        return [responseDone, handlerDone];\r\n    }\r\n    async _getResponse(handler, request, event) {\r\n        await handler.runCallbacks('handlerWillStart', { event, request });\r\n        let response = undefined;\r\n        try {\r\n            response = await this._handle(request, handler);\r\n            // The \"official\" Strategy subclasses all throw this error automatically,\r\n            // but in case a third-party Strategy doesn't, ensure that we have a\r\n            // consistent failure when there's no response or an error response.\r\n            if (!response || response.type === 'error') {\r\n                throw new WorkboxError('no-response', { url: request.url });\r\n            }\r\n        }\r\n        catch (error) {\r\n            for (const callback of handler.iterateCallbacks('handlerDidError')) {\r\n                response = await callback({ error, event, request });\r\n                if (response) {\r\n                    break;\r\n                }\r\n            }\r\n            if (!response) {\r\n                throw error;\r\n            }\r\n            else if (process.env.NODE_ENV !== 'production') {\r\n                logger.log(`While responding to '${getFriendlyURL(request.url)}', ` +\r\n                    `an ${error} error occurred. Using a fallback response provided by ` +\r\n                    `a handlerDidError plugin.`);\r\n            }\r\n        }\r\n        for (const callback of handler.iterateCallbacks('handlerWillRespond')) {\r\n            response = await callback({ event, request, response });\r\n        }\r\n        return response;\r\n    }\r\n    async _awaitComplete(responseDone, handler, request, event) {\r\n        let response;\r\n        let error;\r\n        try {\r\n            response = await responseDone;\r\n        }\r\n        catch (error) {\r\n            // Ignore errors, as response errors should be caught via the `response`\r\n            // promise above. The `done` promise will only throw for errors in\r\n            // promises passed to `handler.waitUntil()`.\r\n        }\r\n        try {\r\n            await handler.runCallbacks('handlerDidRespond', {\r\n                event,\r\n                request,\r\n                response,\r\n            });\r\n            await handler.doneWaiting();\r\n        }\r\n        catch (waitUntilError) {\r\n            error = waitUntilError;\r\n        }\r\n        await handler.runCallbacks('handlerDidComplete', {\r\n            event,\r\n            request,\r\n            response,\r\n            error,\r\n        });\r\n        handler.destroy();\r\n        if (error) {\r\n            throw error;\r\n        }\r\n    }\r\n}\r\nexport { Strategy };\r\n/**\r\n * Classes extending the `Strategy` based class should implement this method,\r\n * and leverage the [`handler`]{@link module:workbox-strategies.StrategyHandler}\r\n * arg to perform all fetching and cache logic, which will ensure all relevant\r\n * cache, cache options, fetch options and plugins are used (per the current\r\n * strategy instance).\r\n *\r\n * @name _handle\r\n * @instance\r\n * @abstract\r\n * @function\r\n * @param {Request} request\r\n * @param {module:workbox-strategies.StrategyHandler} handler\r\n * @return {Promise<Response>}\r\n *\r\n * @memberof module:workbox-strategies.Strategy\r\n */\r\n","/*\r\n  Copyright 2018 Google LLC\r\n\r\n  Use of this source code is governed by an MIT-style\r\n  license that can be found in the LICENSE file or at\r\n  https://opensource.org/licenses/MIT.\r\n*/\r\nimport '../_version.js';\r\nexport const cacheOkAndOpaquePlugin = {\r\n    /**\r\n     * Returns a valid response (to allow caching) if the status is 200 (OK) or\r\n     * 0 (opaque).\r\n     *\r\n     * @param {Object} options\r\n     * @param {Response} options.response\r\n     * @return {Response|null}\r\n     *\r\n     * @private\r\n     */\r\n    cacheWillUpdate: async ({ response }) => {\r\n        if (response.status === 200 || response.status === 0) {\r\n            return response;\r\n        }\r\n        return null;\r\n    },\r\n};\r\n","/*\r\n  Copyright 2018 Google LLC\r\n\r\n  Use of this source code is governed by an MIT-style\r\n  license that can be found in the LICENSE file or at\r\n  https://opensource.org/licenses/MIT.\r\n*/\r\nimport { assert } from 'workbox-core/_private/assert.js';\r\nimport { logger } from 'workbox-core/_private/logger.js';\r\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\r\nimport { Strategy } from './Strategy.js';\r\nimport { messages } from './utils/messages.js';\r\nimport './_version.js';\r\n/**\r\n * An implementation of a [cache-first]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-falling-back-to-network}\r\n * request strategy.\r\n *\r\n * A cache first strategy is useful for assets that have been revisioned,\r\n * such as URLs like `/styles/example.a8f5f1.css`, since they\r\n * can be cached for long periods of time.\r\n *\r\n * If the network request fails, and there is no cache match, this will throw\r\n * a `WorkboxError` exception.\r\n *\r\n * @extends module:workbox-strategies.Strategy\r\n * @memberof module:workbox-strategies\r\n */\r\nclass CacheFirst extends Strategy {\r\n    /**\r\n     * @private\r\n     * @param {Request|string} request A request to run this strategy for.\r\n     * @param {module:workbox-strategies.StrategyHandler} handler The event that\r\n     *     triggered the request.\r\n     * @return {Promise<Response>}\r\n     */\r\n    async _handle(request, handler) {\r\n        const logs = [];\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            assert.isInstance(request, Request, {\r\n                moduleName: 'workbox-strategies',\r\n                className: this.constructor.name,\r\n                funcName: 'makeRequest',\r\n                paramName: 'request',\r\n            });\r\n        }\r\n        let response = await handler.cacheMatch(request);\r\n        let error;\r\n        if (!response) {\r\n            if (process.env.NODE_ENV !== 'production') {\r\n                logs.push(`No response found in the '${this.cacheName}' cache. ` +\r\n                    `Will respond with a network request.`);\r\n            }\r\n            try {\r\n                response = await handler.fetchAndCachePut(request);\r\n            }\r\n            catch (err) {\r\n                error = err;\r\n            }\r\n            if (process.env.NODE_ENV !== 'production') {\r\n                if (response) {\r\n                    logs.push(`Got response from network.`);\r\n                }\r\n                else {\r\n                    logs.push(`Unable to get a response from the network.`);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            if (process.env.NODE_ENV !== 'production') {\r\n                logs.push(`Found a cached response in the '${this.cacheName}' cache.`);\r\n            }\r\n        }\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            logger.groupCollapsed(messages.strategyStart(this.constructor.name, request));\r\n            for (const log of logs) {\r\n                logger.log(log);\r\n            }\r\n            messages.printFinalResponse(response);\r\n            logger.groupEnd();\r\n        }\r\n        if (!response) {\r\n            throw new WorkboxError('no-response', { url: request.url, error });\r\n        }\r\n        return response;\r\n    }\r\n}\r\nexport { CacheFirst };\r\n","/*\r\n  Copyright 2018 Google LLC\r\n\r\n  Use of this source code is governed by an MIT-style\r\n  license that can be found in the LICENSE file or at\r\n  https://opensource.org/licenses/MIT.\r\n*/\r\nimport { assert } from 'workbox-core/_private/assert.js';\r\nimport { logger } from 'workbox-core/_private/logger.js';\r\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\r\nimport { Strategy } from './Strategy.js';\r\nimport { messages } from './utils/messages.js';\r\nimport './_version.js';\r\n/**\r\n * An implementation of a\r\n * [cache-only]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-only}\r\n * request strategy.\r\n *\r\n * This class is useful if you want to take advantage of any\r\n * [Workbox plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}.\r\n *\r\n * If there is no cache match, this will throw a `WorkboxError` exception.\r\n *\r\n * @extends module:workbox-strategies.Strategy\r\n * @memberof module:workbox-strategies\r\n */\r\nclass CacheOnly extends Strategy {\r\n    /**\r\n     * @private\r\n     * @param {Request|string} request A request to run this strategy for.\r\n     * @param {module:workbox-strategies.StrategyHandler} handler The event that\r\n     *     triggered the request.\r\n     * @return {Promise<Response>}\r\n     */\r\n    async _handle(request, handler) {\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            assert.isInstance(request, Request, {\r\n                moduleName: 'workbox-strategies',\r\n                className: this.constructor.name,\r\n                funcName: 'makeRequest',\r\n                paramName: 'request',\r\n            });\r\n        }\r\n        const response = await handler.cacheMatch(request);\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            logger.groupCollapsed(messages.strategyStart(this.constructor.name, request));\r\n            if (response) {\r\n                logger.log(`Found a cached response in the '${this.cacheName}' ` +\r\n                    `cache.`);\r\n                messages.printFinalResponse(response);\r\n            }\r\n            else {\r\n                logger.log(`No response found in the '${this.cacheName}' cache.`);\r\n            }\r\n            logger.groupEnd();\r\n        }\r\n        if (!response) {\r\n            throw new WorkboxError('no-response', { url: request.url });\r\n        }\r\n        return response;\r\n    }\r\n}\r\nexport { CacheOnly };\r\n","/*\r\n  Copyright 2018 Google LLC\r\n\r\n  Use of this source code is governed by an MIT-style\r\n  license that can be found in the LICENSE file or at\r\n  https://opensource.org/licenses/MIT.\r\n*/\r\nimport { assert } from 'workbox-core/_private/assert.js';\r\nimport { logger } from 'workbox-core/_private/logger.js';\r\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\r\nimport { cacheOkAndOpaquePlugin } from './plugins/cacheOkAndOpaquePlugin.js';\r\nimport { Strategy } from './Strategy.js';\r\nimport { messages } from './utils/messages.js';\r\nimport './_version.js';\r\n/**\r\n * An implementation of a\r\n * [network first]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#network-falling-back-to-cache}\r\n * request strategy.\r\n *\r\n * By default, this strategy will cache responses with a 200 status code as\r\n * well as [opaque responses]{@link https://developers.google.com/web/tools/workbox/guides/handle-third-party-requests}.\r\n * Opaque responses are are cross-origin requests where the response doesn't\r\n * support [CORS]{@link https://enable-cors.org/}.\r\n *\r\n * If the network request fails, and there is no cache match, this will throw\r\n * a `WorkboxError` exception.\r\n *\r\n * @extends module:workbox-strategies.Strategy\r\n * @memberof module:workbox-strategies\r\n */\r\nclass NetworkFirst extends Strategy {\r\n    /**\r\n     * @param {Object} [options]\r\n     * @param {string} [options.cacheName] Cache name to store and retrieve\r\n     * requests. Defaults to cache names provided by\r\n     * [workbox-core]{@link module:workbox-core.cacheNames}.\r\n     * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\r\n     * to use in conjunction with this caching strategy.\r\n     * @param {Object} [options.fetchOptions] Values passed along to the\r\n     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\r\n     * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)\r\n     * `fetch()` requests made by this strategy.\r\n     * @param {Object} [options.matchOptions] [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\r\n     * @param {number} [options.networkTimeoutSeconds] If set, any network requests\r\n     * that fail to respond within the timeout will fallback to the cache.\r\n     *\r\n     * This option can be used to combat\r\n     * \"[lie-fi]{@link https://developers.google.com/web/fundamentals/performance/poor-connectivity/#lie-fi}\"\r\n     * scenarios.\r\n     */\r\n    constructor(options = {}) {\r\n        super(options);\r\n        // If this instance contains no plugins with a 'cacheWillUpdate' callback,\r\n        // prepend the `cacheOkAndOpaquePlugin` plugin to the plugins list.\r\n        if (!this.plugins.some((p) => 'cacheWillUpdate' in p)) {\r\n            this.plugins.unshift(cacheOkAndOpaquePlugin);\r\n        }\r\n        this._networkTimeoutSeconds = options.networkTimeoutSeconds || 0;\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            if (this._networkTimeoutSeconds) {\r\n                assert.isType(this._networkTimeoutSeconds, 'number', {\r\n                    moduleName: 'workbox-strategies',\r\n                    className: this.constructor.name,\r\n                    funcName: 'constructor',\r\n                    paramName: 'networkTimeoutSeconds',\r\n                });\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * @private\r\n     * @param {Request|string} request A request to run this strategy for.\r\n     * @param {module:workbox-strategies.StrategyHandler} handler The event that\r\n     *     triggered the request.\r\n     * @return {Promise<Response>}\r\n     */\r\n    async _handle(request, handler) {\r\n        const logs = [];\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            assert.isInstance(request, Request, {\r\n                moduleName: 'workbox-strategies',\r\n                className: this.constructor.name,\r\n                funcName: 'handle',\r\n                paramName: 'makeRequest',\r\n            });\r\n        }\r\n        const promises = [];\r\n        let timeoutId;\r\n        if (this._networkTimeoutSeconds) {\r\n            const { id, promise } = this._getTimeoutPromise({ request, logs, handler });\r\n            timeoutId = id;\r\n            promises.push(promise);\r\n        }\r\n        const networkPromise = this._getNetworkPromise({ timeoutId, request, logs, handler });\r\n        promises.push(networkPromise);\r\n        const response = await handler.waitUntil((async () => {\r\n            // Promise.race() will resolve as soon as the first promise resolves.\r\n            return await handler.waitUntil(Promise.race(promises)) ||\r\n                // If Promise.race() resolved with null, it might be due to a network\r\n                // timeout + a cache miss. If that were to happen, we'd rather wait until\r\n                // the networkPromise resolves instead of returning null.\r\n                // Note that it's fine to await an already-resolved promise, so we don't\r\n                // have to check to see if it's still \"in flight\".\r\n                await networkPromise;\r\n        })());\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            logger.groupCollapsed(messages.strategyStart(this.constructor.name, request));\r\n            for (const log of logs) {\r\n                logger.log(log);\r\n            }\r\n            messages.printFinalResponse(response);\r\n            logger.groupEnd();\r\n        }\r\n        if (!response) {\r\n            throw new WorkboxError('no-response', { url: request.url });\r\n        }\r\n        return response;\r\n    }\r\n    /**\r\n     * @param {Object} options\r\n     * @param {Request} options.request\r\n     * @param {Array} options.logs A reference to the logs array\r\n     * @param {Event} options.event\r\n     * @return {Promise<Response>}\r\n     *\r\n     * @private\r\n     */\r\n    _getTimeoutPromise({ request, logs, handler }) {\r\n        let timeoutId;\r\n        const timeoutPromise = new Promise((resolve) => {\r\n            const onNetworkTimeout = async () => {\r\n                if (process.env.NODE_ENV !== 'production') {\r\n                    logs.push(`Timing out the network response at ` +\r\n                        `${this._networkTimeoutSeconds} seconds.`);\r\n                }\r\n                resolve(await handler.cacheMatch(request));\r\n            };\r\n            timeoutId = setTimeout(onNetworkTimeout, this._networkTimeoutSeconds * 1000);\r\n        });\r\n        return {\r\n            promise: timeoutPromise,\r\n            id: timeoutId,\r\n        };\r\n    }\r\n    /**\r\n     * @param {Object} options\r\n     * @param {number|undefined} options.timeoutId\r\n     * @param {Request} options.request\r\n     * @param {Array} options.logs A reference to the logs Array.\r\n     * @param {Event} options.event\r\n     * @return {Promise<Response>}\r\n     *\r\n     * @private\r\n     */\r\n    async _getNetworkPromise({ timeoutId, request, logs, handler }) {\r\n        let error;\r\n        let response;\r\n        try {\r\n            response = await handler.fetchAndCachePut(request);\r\n        }\r\n        catch (fetchError) {\r\n            error = fetchError;\r\n        }\r\n        if (timeoutId) {\r\n            clearTimeout(timeoutId);\r\n        }\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            if (response) {\r\n                logs.push(`Got response from network.`);\r\n            }\r\n            else {\r\n                logs.push(`Unable to get a response from the network. Will respond ` +\r\n                    `with a cached response.`);\r\n            }\r\n        }\r\n        if (error || !response) {\r\n            response = await handler.cacheMatch(request);\r\n            if (process.env.NODE_ENV !== 'production') {\r\n                if (response) {\r\n                    logs.push(`Found a cached response in the '${this.cacheName}'` +\r\n                        ` cache.`);\r\n                }\r\n                else {\r\n                    logs.push(`No response found in the '${this.cacheName}' cache.`);\r\n                }\r\n            }\r\n        }\r\n        return response;\r\n    }\r\n}\r\nexport { NetworkFirst };\r\n","/*\r\n  Copyright 2018 Google LLC\r\n\r\n  Use of this source code is governed by an MIT-style\r\n  license that can be found in the LICENSE file or at\r\n  https://opensource.org/licenses/MIT.\r\n*/\r\nimport { assert } from 'workbox-core/_private/assert.js';\r\nimport { logger } from 'workbox-core/_private/logger.js';\r\nimport { timeout } from 'workbox-core/_private/timeout.js';\r\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\r\nimport { Strategy } from './Strategy.js';\r\nimport { messages } from './utils/messages.js';\r\nimport './_version.js';\r\n/**\r\n * An implementation of a\r\n * [network-only]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#network-only}\r\n * request strategy.\r\n *\r\n * This class is useful if you want to take advantage of any\r\n * [Workbox plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}.\r\n *\r\n * If the network request fails, this will throw a `WorkboxError` exception.\r\n *\r\n * @extends module:workbox-strategies.Strategy\r\n * @memberof module:workbox-strategies\r\n */\r\nclass NetworkOnly extends Strategy {\r\n    /**\r\n     * @param {Object} [options]\r\n     * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\r\n     * to use in conjunction with this caching strategy.\r\n     * @param {Object} [options.fetchOptions] Values passed along to the\r\n     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\r\n     * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)\r\n     * `fetch()` requests made by this strategy.\r\n     * @param {number} [options.networkTimeoutSeconds] If set, any network requests\r\n     * that fail to respond within the timeout will result in a network error.\r\n     */\r\n    constructor(options = {}) {\r\n        super(options);\r\n        this._networkTimeoutSeconds = options.networkTimeoutSeconds || 0;\r\n    }\r\n    /**\r\n     * @private\r\n     * @param {Request|string} request A request to run this strategy for.\r\n     * @param {module:workbox-strategies.StrategyHandler} handler The event that\r\n     *     triggered the request.\r\n     * @return {Promise<Response>}\r\n     */\r\n    async _handle(request, handler) {\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            assert.isInstance(request, Request, {\r\n                moduleName: 'workbox-strategies',\r\n                className: this.constructor.name,\r\n                funcName: '_handle',\r\n                paramName: 'request',\r\n            });\r\n        }\r\n        let error = undefined;\r\n        let response;\r\n        try {\r\n            const promises = [handler.fetch(request)];\r\n            if (this._networkTimeoutSeconds) {\r\n                const timeoutPromise = timeout(this._networkTimeoutSeconds * 1000);\r\n                promises.push(timeoutPromise);\r\n            }\r\n            response = await Promise.race(promises);\r\n            if (!response) {\r\n                throw new Error(`Timed out the network response after ` +\r\n                    `${this._networkTimeoutSeconds} seconds.`);\r\n            }\r\n        }\r\n        catch (err) {\r\n            error = err;\r\n        }\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            logger.groupCollapsed(messages.strategyStart(this.constructor.name, request));\r\n            if (response) {\r\n                logger.log(`Got response from network.`);\r\n            }\r\n            else {\r\n                logger.log(`Unable to get a response from the network.`);\r\n            }\r\n            messages.printFinalResponse(response);\r\n            logger.groupEnd();\r\n        }\r\n        if (!response) {\r\n            throw new WorkboxError('no-response', { url: request.url, error });\r\n        }\r\n        return response;\r\n    }\r\n}\r\nexport { NetworkOnly };\r\n","/*\r\n  Copyright 2018 Google LLC\r\n\r\n  Use of this source code is governed by an MIT-style\r\n  license that can be found in the LICENSE file or at\r\n  https://opensource.org/licenses/MIT.\r\n*/\r\nimport { assert } from 'workbox-core/_private/assert.js';\r\nimport { logger } from 'workbox-core/_private/logger.js';\r\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\r\nimport { cacheOkAndOpaquePlugin } from './plugins/cacheOkAndOpaquePlugin.js';\r\nimport { Strategy } from './Strategy.js';\r\nimport { messages } from './utils/messages.js';\r\nimport './_version.js';\r\n/**\r\n * An implementation of a\r\n * [stale-while-revalidate]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#stale-while-revalidate}\r\n * request strategy.\r\n *\r\n * Resources are requested from both the cache and the network in parallel.\r\n * The strategy will respond with the cached version if available, otherwise\r\n * wait for the network response. The cache is updated with the network response\r\n * with each successful request.\r\n *\r\n * By default, this strategy will cache responses with a 200 status code as\r\n * well as [opaque responses]{@link https://developers.google.com/web/tools/workbox/guides/handle-third-party-requests}.\r\n * Opaque responses are cross-origin requests where the response doesn't\r\n * support [CORS]{@link https://enable-cors.org/}.\r\n *\r\n * If the network request fails, and there is no cache match, this will throw\r\n * a `WorkboxError` exception.\r\n *\r\n * @extends module:workbox-strategies.Strategy\r\n * @memberof module:workbox-strategies\r\n */\r\nclass StaleWhileRevalidate extends Strategy {\r\n    /**\r\n     * @param {Object} [options]\r\n     * @param {string} [options.cacheName] Cache name to store and retrieve\r\n     * requests. Defaults to cache names provided by\r\n     * [workbox-core]{@link module:workbox-core.cacheNames}.\r\n     * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\r\n     * to use in conjunction with this caching strategy.\r\n     * @param {Object} [options.fetchOptions] Values passed along to the\r\n     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\r\n     * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)\r\n     * `fetch()` requests made by this strategy.\r\n     * @param {Object} [options.matchOptions] [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\r\n     */\r\n    constructor(options) {\r\n        super(options);\r\n        // If this instance contains no plugins with a 'cacheWillUpdate' callback,\r\n        // prepend the `cacheOkAndOpaquePlugin` plugin to the plugins list.\r\n        if (!this.plugins.some((p) => 'cacheWillUpdate' in p)) {\r\n            this.plugins.unshift(cacheOkAndOpaquePlugin);\r\n        }\r\n    }\r\n    /**\r\n     * @private\r\n     * @param {Request|string} request A request to run this strategy for.\r\n     * @param {module:workbox-strategies.StrategyHandler} handler The event that\r\n     *     triggered the request.\r\n     * @return {Promise<Response>}\r\n     */\r\n    async _handle(request, handler) {\r\n        const logs = [];\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            assert.isInstance(request, Request, {\r\n                moduleName: 'workbox-strategies',\r\n                className: this.constructor.name,\r\n                funcName: 'handle',\r\n                paramName: 'request',\r\n            });\r\n        }\r\n        const fetchAndCachePromise = handler\r\n            .fetchAndCachePut(request)\r\n            .catch(() => {\r\n            // Swallow this error because a 'no-response' error will be thrown in\r\n            // main handler return flow. This will be in the `waitUntil()` flow.\r\n        });\r\n        let response = await handler.cacheMatch(request);\r\n        let error;\r\n        if (response) {\r\n            if (process.env.NODE_ENV !== 'production') {\r\n                logs.push(`Found a cached response in the '${this.cacheName}'` +\r\n                    ` cache. Will update with the network response in the background.`);\r\n            }\r\n        }\r\n        else {\r\n            if (process.env.NODE_ENV !== 'production') {\r\n                logs.push(`No response found in the '${this.cacheName}' cache. ` +\r\n                    `Will wait for the network response.`);\r\n            }\r\n            try {\r\n                // NOTE(philipwalton): Really annoying that we have to type cast here.\r\n                // https://github.com/microsoft/TypeScript/issues/20006\r\n                response = await fetchAndCachePromise;\r\n            }\r\n            catch (err) {\r\n                error = err;\r\n            }\r\n        }\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            logger.groupCollapsed(messages.strategyStart(this.constructor.name, request));\r\n            for (const log of logs) {\r\n                logger.log(log);\r\n            }\r\n            messages.printFinalResponse(response);\r\n            logger.groupEnd();\r\n        }\r\n        if (!response) {\r\n            throw new WorkboxError('no-response', { url: request.url, error });\r\n        }\r\n        return response;\r\n    }\r\n}\r\nexport { StaleWhileRevalidate };\r\n"],"names":["self","_","e","toRequest","input","Request","StrategyHandler","constructor","strategy","options","_cacheKeys","Object","assign","this","event","_strategy","_handlerDeferred","Deferred","_extendLifetimePromises","_plugins","plugins","_pluginStateMap","Map","plugin","set","waitUntil","promise","request","mode","FetchEvent","preloadResponse","possiblePreloadResponse","originalRequest","hasCallback","clone","cb","iterateCallbacks","err","WorkboxError","thrownError","pluginFilteredRequest","fetchResponse","fetch","undefined","fetchOptions","callback","response","error","runCallbacks","responseClone","cachePut","key","cachedResponse","cacheName","matchOptions","effectiveRequest","getCacheKey","multiMatchOptions","caches","match","timeout","url","getFriendlyURL","responseToCache","_ensureResponseSafeToCache","cache","open","hasCacheUpdateCallback","oldResponse","cacheMatchIgnoreParams","put","name","executeQuotaErrorCallbacks","newResponse","params","param","state","get","statefulCallback","statefulParam","push","shift","destroy","resolve","pluginsUsed","status","Strategy","cacheNames","getRuntimeName","handle","responseDone","handleAll","handler","_getResponse","_awaitComplete","_handle","type","doneWaiting","waitUntilError","cacheOkAndOpaquePlugin","cacheWillUpdate","async","cacheMatch","fetchAndCachePut","some","p","unshift","_networkTimeoutSeconds","networkTimeoutSeconds","logs","promises","timeoutId","id","_getTimeoutPromise","networkPromise","_getNetworkPromise","Promise","race","setTimeout","fetchError","clearTimeout","timeoutPromise","Error","fetchAndCachePromise","catch"],"mappings":"8SAEA,IACIA,KAAK,6BAA+BC,IAExC,MAAOC,ICWP,SAASC,EAAUC,SACU,iBAAVA,EAAsB,IAAIC,QAAQD,GAASA,EAW9D,MAAME,EAkBFC,YAAYC,EAAUC,QACbC,GAAa,GA8ClBC,OAAOC,OAAOC,KAAMJ,QACfK,MAAQL,EAAQK,WAChBC,GAAYP,OACZQ,GAAmB,IAAIC,gBACvBC,GAA0B,QAG1BC,GAAW,IAAIX,EAASY,cACxBC,GAAkB,IAAIC,QACtB,MAAMC,KAAUV,KAAKM,QACjBE,GAAgBG,IAAID,EAAQ,SAEhCT,MAAMW,UAAUZ,KAAKG,GAAiBU,qBAenCtB,SACFU,MAAEA,GAAUD,SACdc,EAAUxB,EAAUC,MACH,aAAjBuB,EAAQC,MACRd,aAAiBe,YACjBf,EAAMgB,gBAAiB,OACjBC,QAAgCjB,EAAMgB,mBACxCC,SAKOA,QAMTC,EAAkBnB,KAAKoB,YAAY,gBACrCN,EAAQO,QAAU,aAEb,MAAMC,KAAMtB,KAAKuB,iBAAiB,oBACnCT,QAAgBQ,EAAG,CAAER,QAASA,EAAQO,QAASpB,MAAAA,IAGvD,MAAOuB,SACG,IAAIC,eAAa,kCAAmC,CACtDC,YAAaF,UAMfG,EAAwBb,EAAQO,gBAE9BO,EAEJA,QAAsBC,MAAMf,EAA0B,aAAjBA,EAAQC,UACzCe,EAAY9B,KAAKE,GAAU6B,kBAM1B,MAAMC,KAAYhC,KAAKuB,iBAAiB,mBACzCK,QAAsBI,EAAS,CAC3B/B,MAAAA,EACAa,QAASa,EACTM,SAAUL,WAGXA,EAEX,MAAOM,SAOCf,SACMnB,KAAKmC,aAAa,eAAgB,CACpCD,MAAAA,EACAjC,MAAAA,EACAkB,gBAAiBA,EAAgBE,QACjCP,QAASa,EAAsBN,UAGjCa,0BAaS3C,SACb0C,QAAiBjC,KAAK6B,MAAMtC,GAC5B6C,EAAgBH,EAASZ,oBAC1BT,UAAUZ,KAAKqC,SAAS9C,EAAO6C,IAC7BH,mBAcMK,SACPxB,EAAUxB,EAAUgD,OACtBC,QACEC,UAAEA,EAAFC,aAAaA,GAAiBzC,KAAKE,GACnCwC,QAAyB1C,KAAK2C,YAAY7B,EAAS,QACnD8B,OAAyBH,EAAiB,CAAED,UAAAA,IAClDD,QAAuBM,OAAOC,MAAMJ,EAAkBE,OASjD,MAAMZ,KAAYhC,KAAKuB,iBAAiB,4BACzCgB,QAAwBP,EAAS,CAC7BQ,UAAAA,EACAC,aAAAA,EACAF,eAAAA,EACAzB,QAAS4B,EACTzC,MAAOD,KAAKC,cACT6B,SAEJS,iBAiBID,EAAKL,SACVnB,EAAUxB,EAAUgD,SAGpBS,UAAQ,SACRL,QAAyB1C,KAAK2C,YAAY7B,EAAS,aASpDmB,QAKK,IAAIR,eAAa,6BAA8B,CACjDuB,IAAKC,iBAAeP,EAAiBM,aAGvCE,QAAwBlD,KAAKmD,GAA2BlB,OACzDiB,SAKM,QAELV,UAAEA,EAAFC,aAAaA,GAAiBzC,KAAKE,GACnCkD,QAAcjE,KAAK0D,OAAOQ,KAAKb,GAC/Bc,EAAyBtD,KAAKoB,YAAY,kBAC1CmC,EAAcD,QAA+BE,yBAInDJ,EAAOV,EAAiBrB,QAAS,CAAC,mBAAoBoB,GAClD,eAMMW,EAAMK,IAAIf,EAAkBY,EAC9BJ,EAAgB7B,QAAU6B,GAElC,MAAOhB,QAEgB,uBAAfA,EAAMwB,YACAC,+BAEJzB,MAEL,MAAMF,KAAYhC,KAAKuB,iBAAiB,wBACnCS,EAAS,CACXQ,UAAAA,EACAe,YAAAA,EACAK,YAAaV,EAAgB7B,QAC7BP,QAAS4B,EACTzC,MAAOD,KAAKC,eAGb,oBAaOa,EAASC,OAClBf,KAAKH,GAAWkB,GAAO,KACpB2B,EAAmB5B,MAClB,MAAMkB,KAAYhC,KAAKuB,iBAAiB,sBACzCmB,EAAmBpD,QAAgB0C,EAAS,CACxCjB,KAAAA,EACAD,QAAS4B,EACTzC,MAAOD,KAAKC,MACZ4D,OAAQ7D,KAAK6D,eAGhBhE,GAAWkB,GAAQ2B,SAErB1C,KAAKH,GAAWkB,GAS3BK,YAAYsC,OACH,MAAMhD,KAAUV,KAAKE,GAAUK,WAC5BmD,KAAQhD,SACD,SAGR,qBAkBQgD,EAAMI,OAChB,MAAM9B,KAAYhC,KAAKuB,iBAAiBmC,SAGnC1B,EAAS8B,qBAYLJ,OACT,MAAMhD,KAAUV,KAAKE,GAAUK,WACJ,mBAAjBG,EAAOgD,GAAsB,OAC9BK,EAAQ/D,KAAKQ,GAAgBwD,IAAItD,GACjCuD,EAAoBH,UAChBI,OAAqBJ,GAAOC,MAAAA,WAG3BrD,EAAOgD,GAAMQ,UAElBD,GAiBlBrD,UAAUC,eACDR,GAAwB8D,KAAKtD,GAC3BA,0BAaHA,OACGA,EAAUb,KAAKK,GAAwB+D,eACpCvD,EAOdwD,eACSlE,GAAiBmE,mBAYOrC,OACzBiB,EAAkBjB,EAClBsC,GAAc,MACb,MAAMvC,KAAYhC,KAAKuB,iBAAiB,sBACzC2B,QAAyBlB,EAAS,CAC9BlB,QAASd,KAAKc,QACdmB,SAAUiB,EACVjD,MAAOD,KAAKC,cACT6B,EACPyC,GAAc,GACTrB,eAIJqB,GACGrB,GAA8C,MAA3BA,EAAgBsB,SACnCtB,OAAkBpB,GAmBnBoB,GChef,MAAMuB,EAuBF/E,YAAYE,EAAU,SAQb4C,UAAYkC,aAAWC,eAAe/E,EAAQ4C,gBAQ9CjC,QAAUX,EAAQW,SAAW,QAQ7BwB,aAAenC,EAAQmC,kBAQvBU,aAAe7C,EAAQ6C,aAqBhCmC,OAAOhF,SACIiF,GAAgB7E,KAAK8E,UAAUlF,UAC/BiF,EAwBXC,UAAUlF,GAEFA,aAAmBoB,aACnBpB,EAAU,CACNK,MAAOL,EACPkB,QAASlB,EAAQkB,gBAGnBb,EAAQL,EAAQK,MAChBa,EAAqC,iBAApBlB,EAAQkB,QAC3B,IAAItB,QAAQI,EAAQkB,SACpBlB,EAAQkB,QACN+C,EAAS,WAAYjE,EAAUA,EAAQiE,YAAS/B,EAChDiD,EAAU,IAAItF,EAAgBO,KAAM,CAAEC,MAAAA,EAAOa,QAAAA,EAAS+C,OAAAA,IACtDgB,EAAe7E,KAAKgF,GAAaD,EAASjE,EAASb,SAGlD,CAAC4E,EAFY7E,KAAKiF,GAAeJ,EAAcE,EAASjE,EAASb,aAIzD8E,EAASjE,EAASb,OAE7BgC,QADE8C,EAAQ5C,aAAa,mBAAoB,CAAElC,MAAAA,EAAOa,QAAAA,WAGpDmB,QAAiBjC,KAAKkF,QAAQpE,EAASiE,IAIlC9C,GAA8B,UAAlBA,EAASkD,WAChB,IAAI1D,eAAa,cAAe,CAAEuB,IAAKlC,EAAQkC,MAG7D,MAAOd,OACE,MAAMF,KAAY+C,EAAQxD,iBAAiB,sBAC5CU,QAAiBD,EAAS,CAAEE,MAAAA,EAAOjC,MAAAA,EAAOa,QAAAA,IACtCmB,YAIHA,QACKC,MAQT,MAAMF,KAAY+C,EAAQxD,iBAAiB,sBAC5CU,QAAiBD,EAAS,CAAE/B,MAAAA,EAAOa,QAAAA,EAASmB,SAAAA,WAEzCA,WAEU4C,EAAcE,EAASjE,EAASb,OAC7CgC,EACAC,MAEAD,QAAiB4C,EAErB,MAAO3C,cAMG6C,EAAQ5C,aAAa,oBAAqB,CAC5ClC,MAAAA,EACAa,QAAAA,EACAmB,SAAAA,UAEE8C,EAAQK,cAElB,MAAOC,GACHnD,EAAQmD,WAENN,EAAQ5C,aAAa,qBAAsB,CAC7ClC,MAAAA,EACAa,QAAAA,EACAmB,SAAAA,EACAC,MAAAA,IAEJ6C,EAAQV,UACJnC,QACMA,GClMX,MAAMoD,EAAyB,CAWlCC,gBAAiBC,OAASvD,SAAAA,KACE,MAApBA,EAASuC,QAAsC,IAApBvC,EAASuC,OAC7BvC,EAEJ,0BCIf,cAAyBwC,gBAQP3D,EAASiE,OAWf7C,EADAD,QAAiB8C,EAAQU,WAAW3E,OAEnCmB,MAMGA,QAAiB8C,EAAQW,iBAAiB5E,GAE9C,MAAOU,GACHU,EAAQV,MAwBXS,QACK,IAAIR,eAAa,cAAe,CAAEuB,IAAKlC,EAAQkC,IAAKd,MAAAA,WAEvDD,gBCzDf,cAAwBwC,gBAQN3D,EAASiE,SASb9C,QAAiB8C,EAAQU,WAAW3E,OAarCmB,QACK,IAAIR,eAAa,cAAe,CAAEuB,IAAKlC,EAAQkC,aAElDf,mBC7Bf,cAA2BwC,EAoBvB/E,YAAYE,EAAU,UACZA,GAGDI,KAAKO,QAAQoF,MAAMC,GAAM,oBAAqBA,UAC1CrF,QAAQsF,QAAQP,QAEpBQ,GAAyBlG,EAAQmG,uBAAyB,gBAmBrDjF,EAASiE,SACbiB,EAAO,GASPC,EAAW,OACbC,KACAlG,KAAK8F,GAAwB,OACvBK,GAAEA,EAAFtF,QAAMA,GAAYb,KAAKoG,GAAmB,CAAEtF,QAAAA,EAASkF,KAAAA,EAAMjB,QAAAA,IACjEmB,EAAYC,EACZF,EAAS9B,KAAKtD,SAEZwF,EAAiBrG,KAAKsG,GAAmB,CAAEJ,UAAAA,EAAWpF,QAAAA,EAASkF,KAAAA,EAAMjB,QAAAA,IAC3EkB,EAAS9B,KAAKkC,SACRpE,QAAiB8C,EAAQnE,UAAU,gBAExBmE,EAAQnE,UAAU2F,QAAQC,KAAKP,WAMlCI,EAR2B,QAkBpCpE,QACK,IAAIR,eAAa,cAAe,CAAEuB,IAAKlC,EAAQkC,aAElDf,EAWXmE,IAAmBtF,QAAEA,EAAFkF,KAAWA,EAAXjB,QAAiBA,QAC5BmB,QAWG,CACHrF,QAXmB,IAAI0F,SAASjC,IAQhC4B,EAAYO,YAPajB,UAKrBlB,QAAcS,EAAQU,WAAW3E,MAEkC,IAA9Bd,KAAK8F,OAI9CK,GAAID,aAaaA,UAAEA,EAAFpF,QAAaA,EAAbkF,KAAsBA,EAAtBjB,QAA4BA,QAC7C7C,EACAD,MAEAA,QAAiB8C,EAAQW,iBAAiB5E,GAE9C,MAAO4F,GACHxE,EAAQwE,SAERR,GACAS,aAAaT,IAWbhE,GAAUD,IACVA,QAAiB8C,EAAQU,WAAW3E,IAWjCmB,kBChKf,cAA0BwC,EAYtB/E,YAAYE,EAAU,UACZA,QACDkG,GAAyBlG,EAAQmG,uBAAyB,gBASrDjF,EAASiE,OASf7C,EACAD,YAEMgE,EAAW,CAAClB,EAAQlD,MAAMf,OAC5Bd,KAAK8F,GAAwB,OACvBc,EAAiB7D,UAAsC,IAA9B/C,KAAK8F,IACpCG,EAAS9B,KAAKyC,MAElB3E,QAAiBsE,QAAQC,KAAKP,IACzBhE,QACK,IAAI4E,MACL,wCAAE7G,KAAK8F,eAGpB,MAAOtE,GACHU,EAAQV,MAaPS,QACK,IAAIR,eAAa,cAAe,CAAEuB,IAAKlC,EAAQkC,IAAKd,MAAAA,WAEvDD,2BCvDf,cAAmCwC,EAc/B/E,YAAYE,SACFA,GAGDI,KAAKO,QAAQoF,MAAMC,GAAM,oBAAqBA,UAC1CrF,QAAQsF,QAAQP,iBAUfxE,EAASiE,SAUb+B,EAAuB/B,EACxBW,iBAAiB5E,GACjBiG,OAAM,aAKP7E,EADAD,QAAiB8C,EAAQU,WAAW3E,MAEpCmB,YAcIA,QAAiB6E,EAErB,MAAOtF,GACHU,EAAQV,MAWXS,QACK,IAAIR,eAAa,cAAe,CAAEuB,IAAKlC,EAAQkC,IAAKd,MAAAA,WAEvDD"}