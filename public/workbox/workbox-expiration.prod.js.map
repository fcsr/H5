{"version":3,"file":"workbox-expiration.prod.js","sources":["../_version.js","../models/CacheTimestampsModel.js","../CacheExpiration.js","../ExpirationPlugin.js"],"sourcesContent":["\"use strict\";\r\n// @ts-ignore\r\ntry {\r\n    self['workbox:expiration:6.1.5'] && _();\r\n}\r\ncatch (e) { }\r\n","/*\r\n  Copyright 2018 Google LLC\r\n\r\n  Use of this source code is governed by an MIT-style\r\n  license that can be found in the LICENSE file or at\r\n  https://opensource.org/licenses/MIT.\r\n*/\r\nimport { DBWrapper } from 'workbox-core/_private/DBWrapper.js';\r\nimport { deleteDatabase } from 'workbox-core/_private/deleteDatabase.js';\r\nimport '../_version.js';\r\nconst DB_NAME = 'workbox-expiration';\r\nconst OBJECT_STORE_NAME = 'cache-entries';\r\nconst normalizeURL = (unNormalizedUrl) => {\r\n    const url = new URL(unNormalizedUrl, location.href);\r\n    url.hash = '';\r\n    return url.href;\r\n};\r\n/**\r\n * Returns the timestamp model.\r\n *\r\n * @private\r\n */\r\nclass CacheTimestampsModel {\r\n    /**\r\n     *\r\n     * @param {string} cacheName\r\n     *\r\n     * @private\r\n     */\r\n    constructor(cacheName) {\r\n        this._cacheName = cacheName;\r\n        this._db = new DBWrapper(DB_NAME, 1, {\r\n            onupgradeneeded: (event) => this._handleUpgrade(event),\r\n        });\r\n    }\r\n    /**\r\n     * Should perform an upgrade of indexedDB.\r\n     *\r\n     * @param {Event} event\r\n     *\r\n     * @private\r\n     */\r\n    _handleUpgrade(event) {\r\n        const db = event.target.result;\r\n        // TODO(philipwalton): EdgeHTML doesn't support arrays as a keyPath, so we\r\n        // have to use the `id` keyPath here and create our own values (a\r\n        // concatenation of `url + cacheName`) instead of simply using\r\n        // `keyPath: ['url', 'cacheName']`, which is supported in other browsers.\r\n        const objStore = db.createObjectStore(OBJECT_STORE_NAME, { keyPath: 'id' });\r\n        // TODO(philipwalton): once we don't have to support EdgeHTML, we can\r\n        // create a single index with the keyPath `['cacheName', 'timestamp']`\r\n        // instead of doing both these indexes.\r\n        objStore.createIndex('cacheName', 'cacheName', { unique: false });\r\n        objStore.createIndex('timestamp', 'timestamp', { unique: false });\r\n        // Previous versions of `workbox-expiration` used `this._cacheName`\r\n        // as the IDBDatabase name.\r\n        deleteDatabase(this._cacheName);\r\n    }\r\n    /**\r\n     * @param {string} url\r\n     * @param {number} timestamp\r\n     *\r\n     * @private\r\n     */\r\n    async setTimestamp(url, timestamp) {\r\n        url = normalizeURL(url);\r\n        const entry = {\r\n            url,\r\n            timestamp,\r\n            cacheName: this._cacheName,\r\n            // Creating an ID from the URL and cache name won't be necessary once\r\n            // Edge switches to Chromium and all browsers we support work with\r\n            // array keyPaths.\r\n            id: this._getId(url),\r\n        };\r\n        await this._db.put(OBJECT_STORE_NAME, entry);\r\n    }\r\n    /**\r\n     * Returns the timestamp stored for a given URL.\r\n     *\r\n     * @param {string} url\r\n     * @return {number}\r\n     *\r\n     * @private\r\n     */\r\n    async getTimestamp(url) {\r\n        const entry = await this._db.get(OBJECT_STORE_NAME, this._getId(url));\r\n        return entry.timestamp;\r\n    }\r\n    /**\r\n     * Iterates through all the entries in the object store (from newest to\r\n     * oldest) and removes entries once either `maxCount` is reached or the\r\n     * entry's timestamp is less than `minTimestamp`.\r\n     *\r\n     * @param {number} minTimestamp\r\n     * @param {number} maxCount\r\n     * @return {Array<string>}\r\n     *\r\n     * @private\r\n     */\r\n    async expireEntries(minTimestamp, maxCount) {\r\n        const entriesToDelete = await this._db.transaction(OBJECT_STORE_NAME, 'readwrite', (txn, done) => {\r\n            const store = txn.objectStore(OBJECT_STORE_NAME);\r\n            const request = store.index('timestamp').openCursor(null, 'prev');\r\n            const entriesToDelete = [];\r\n            let entriesNotDeletedCount = 0;\r\n            request.onsuccess = () => {\r\n                const cursor = request.result;\r\n                if (cursor) {\r\n                    const result = cursor.value;\r\n                    // TODO(philipwalton): once we can use a multi-key index, we\r\n                    // won't have to check `cacheName` here.\r\n                    if (result.cacheName === this._cacheName) {\r\n                        // Delete an entry if it's older than the max age or\r\n                        // if we already have the max number allowed.\r\n                        if ((minTimestamp && result.timestamp < minTimestamp) ||\r\n                            (maxCount && entriesNotDeletedCount >= maxCount)) {\r\n                            // TODO(philipwalton): we should be able to delete the\r\n                            // entry right here, but doing so causes an iteration\r\n                            // bug in Safari stable (fixed in TP). Instead we can\r\n                            // store the keys of the entries to delete, and then\r\n                            // delete the separate transactions.\r\n                            // https://github.com/GoogleChrome/workbox/issues/1978\r\n                            // cursor.delete();\r\n                            // We only need to return the URL, not the whole entry.\r\n                            entriesToDelete.push(cursor.value);\r\n                        }\r\n                        else {\r\n                            entriesNotDeletedCount++;\r\n                        }\r\n                    }\r\n                    cursor.continue();\r\n                }\r\n                else {\r\n                    done(entriesToDelete);\r\n                }\r\n            };\r\n        });\r\n        // TODO(philipwalton): once the Safari bug in the following issue is fixed,\r\n        // we should be able to remove this loop and do the entry deletion in the\r\n        // cursor loop above:\r\n        // https://github.com/GoogleChrome/workbox/issues/1978\r\n        const urlsDeleted = [];\r\n        for (const entry of entriesToDelete) {\r\n            await this._db.delete(OBJECT_STORE_NAME, entry.id);\r\n            urlsDeleted.push(entry.url);\r\n        }\r\n        return urlsDeleted;\r\n    }\r\n    /**\r\n     * Takes a URL and returns an ID that will be unique in the object store.\r\n     *\r\n     * @param {string} url\r\n     * @return {string}\r\n     *\r\n     * @private\r\n     */\r\n    _getId(url) {\r\n        // Creating an ID from the URL and cache name won't be necessary once\r\n        // Edge switches to Chromium and all browsers we support work with\r\n        // array keyPaths.\r\n        return this._cacheName + '|' + normalizeURL(url);\r\n    }\r\n}\r\nexport { CacheTimestampsModel };\r\n","/*\r\n  Copyright 2018 Google LLC\r\n\r\n  Use of this source code is governed by an MIT-style\r\n  license that can be found in the LICENSE file or at\r\n  https://opensource.org/licenses/MIT.\r\n*/\r\nimport { assert } from 'workbox-core/_private/assert.js';\r\nimport { dontWaitFor } from 'workbox-core/_private/dontWaitFor.js';\r\nimport { logger } from 'workbox-core/_private/logger.js';\r\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\r\nimport { CacheTimestampsModel } from './models/CacheTimestampsModel.js';\r\nimport './_version.js';\r\n/**\r\n * The `CacheExpiration` class allows you define an expiration and / or\r\n * limit on the number of responses stored in a\r\n * [`Cache`](https://developer.mozilla.org/en-US/docs/Web/API/Cache).\r\n *\r\n * @memberof module:workbox-expiration\r\n */\r\nclass CacheExpiration {\r\n    /**\r\n     * To construct a new CacheExpiration instance you must provide at least\r\n     * one of the `config` properties.\r\n     *\r\n     * @param {string} cacheName Name of the cache to apply restrictions to.\r\n     * @param {Object} config\r\n     * @param {number} [config.maxEntries] The maximum number of entries to cache.\r\n     * Entries used the least will be removed as the maximum is reached.\r\n     * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\r\n     * it's treated as stale and removed.\r\n     * @param {Object} [config.matchOptions] The [`CacheQueryOptions`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/delete#Parameters)\r\n     * that will be used when calling `delete()` on the cache.\r\n     */\r\n    constructor(cacheName, config = {}) {\r\n        this._isRunning = false;\r\n        this._rerunRequested = false;\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            assert.isType(cacheName, 'string', {\r\n                moduleName: 'workbox-expiration',\r\n                className: 'CacheExpiration',\r\n                funcName: 'constructor',\r\n                paramName: 'cacheName',\r\n            });\r\n            if (!(config.maxEntries || config.maxAgeSeconds)) {\r\n                throw new WorkboxError('max-entries-or-age-required', {\r\n                    moduleName: 'workbox-expiration',\r\n                    className: 'CacheExpiration',\r\n                    funcName: 'constructor',\r\n                });\r\n            }\r\n            if (config.maxEntries) {\r\n                assert.isType(config.maxEntries, 'number', {\r\n                    moduleName: 'workbox-expiration',\r\n                    className: 'CacheExpiration',\r\n                    funcName: 'constructor',\r\n                    paramName: 'config.maxEntries',\r\n                });\r\n            }\r\n            if (config.maxAgeSeconds) {\r\n                assert.isType(config.maxAgeSeconds, 'number', {\r\n                    moduleName: 'workbox-expiration',\r\n                    className: 'CacheExpiration',\r\n                    funcName: 'constructor',\r\n                    paramName: 'config.maxAgeSeconds',\r\n                });\r\n            }\r\n        }\r\n        this._maxEntries = config.maxEntries;\r\n        this._maxAgeSeconds = config.maxAgeSeconds;\r\n        this._matchOptions = config.matchOptions;\r\n        this._cacheName = cacheName;\r\n        this._timestampModel = new CacheTimestampsModel(cacheName);\r\n    }\r\n    /**\r\n     * Expires entries for the given cache and given criteria.\r\n     */\r\n    async expireEntries() {\r\n        if (this._isRunning) {\r\n            this._rerunRequested = true;\r\n            return;\r\n        }\r\n        this._isRunning = true;\r\n        const minTimestamp = this._maxAgeSeconds ?\r\n            Date.now() - (this._maxAgeSeconds * 1000) : 0;\r\n        const urlsExpired = await this._timestampModel.expireEntries(minTimestamp, this._maxEntries);\r\n        // Delete URLs from the cache\r\n        const cache = await self.caches.open(this._cacheName);\r\n        for (const url of urlsExpired) {\r\n            await cache.delete(url, this._matchOptions);\r\n        }\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            if (urlsExpired.length > 0) {\r\n                logger.groupCollapsed(`Expired ${urlsExpired.length} ` +\r\n                    `${urlsExpired.length === 1 ? 'entry' : 'entries'} and removed ` +\r\n                    `${urlsExpired.length === 1 ? 'it' : 'them'} from the ` +\r\n                    `'${this._cacheName}' cache.`);\r\n                logger.log(`Expired the following ${urlsExpired.length === 1 ?\r\n                    'URL' : 'URLs'}:`);\r\n                urlsExpired.forEach((url) => logger.log(`    ${url}`));\r\n                logger.groupEnd();\r\n            }\r\n            else {\r\n                logger.debug(`Cache expiration ran and found no entries to remove.`);\r\n            }\r\n        }\r\n        this._isRunning = false;\r\n        if (this._rerunRequested) {\r\n            this._rerunRequested = false;\r\n            dontWaitFor(this.expireEntries());\r\n        }\r\n    }\r\n    /**\r\n     * Update the timestamp for the given URL. This ensures the when\r\n     * removing entries based on maximum entries, most recently used\r\n     * is accurate or when expiring, the timestamp is up-to-date.\r\n     *\r\n     * @param {string} url\r\n     */\r\n    async updateTimestamp(url) {\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            assert.isType(url, 'string', {\r\n                moduleName: 'workbox-expiration',\r\n                className: 'CacheExpiration',\r\n                funcName: 'updateTimestamp',\r\n                paramName: 'url',\r\n            });\r\n        }\r\n        await this._timestampModel.setTimestamp(url, Date.now());\r\n    }\r\n    /**\r\n     * Can be used to check if a URL has expired or not before it's used.\r\n     *\r\n     * This requires a look up from IndexedDB, so can be slow.\r\n     *\r\n     * Note: This method will not remove the cached entry, call\r\n     * `expireEntries()` to remove indexedDB and Cache entries.\r\n     *\r\n     * @param {string} url\r\n     * @return {boolean}\r\n     */\r\n    async isURLExpired(url) {\r\n        if (!this._maxAgeSeconds) {\r\n            if (process.env.NODE_ENV !== 'production') {\r\n                throw new WorkboxError(`expired-test-without-max-age`, {\r\n                    methodName: 'isURLExpired',\r\n                    paramName: 'maxAgeSeconds',\r\n                });\r\n            }\r\n            return false;\r\n        }\r\n        else {\r\n            const timestamp = await this._timestampModel.getTimestamp(url);\r\n            const expireOlderThan = Date.now() - (this._maxAgeSeconds * 1000);\r\n            return (timestamp < expireOlderThan);\r\n        }\r\n    }\r\n    /**\r\n     * Removes the IndexedDB object store used to keep track of cache expiration\r\n     * metadata.\r\n     */\r\n    async delete() {\r\n        // Make sure we don't attempt another rerun if we're called in the middle of\r\n        // a cache expiration.\r\n        this._rerunRequested = false;\r\n        await this._timestampModel.expireEntries(Infinity); // Expires all.\r\n    }\r\n}\r\nexport { CacheExpiration };\r\n","/*\r\n  Copyright 2018 Google LLC\r\n\r\n  Use of this source code is governed by an MIT-style\r\n  license that can be found in the LICENSE file or at\r\n  https://opensource.org/licenses/MIT.\r\n*/\r\nimport { assert } from 'workbox-core/_private/assert.js';\r\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\r\nimport { dontWaitFor } from 'workbox-core/_private/dontWaitFor.js';\r\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\r\nimport { logger } from 'workbox-core/_private/logger.js';\r\nimport { registerQuotaErrorCallback } from 'workbox-core/registerQuotaErrorCallback.js';\r\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\r\nimport { CacheExpiration } from './CacheExpiration.js';\r\nimport './_version.js';\r\n/**\r\n * This plugin can be used in a `workbox-strategy` to regularly enforce a\r\n * limit on the age and / or the number of cached requests.\r\n *\r\n * It can only be used with `workbox-strategy` instances that have a\r\n * [custom `cacheName` property set](/web/tools/workbox/guides/configure-workbox#custom_cache_names_in_strategies).\r\n * In other words, it can't be used to expire entries in strategy that uses the\r\n * default runtime cache name.\r\n *\r\n * Whenever a cached request is used or updated, this plugin will look\r\n * at the associated cache and remove any old or extra requests.\r\n *\r\n * When using `maxAgeSeconds`, requests may be used *once* after expiring\r\n * because the expiration clean up will not have occurred until *after* the\r\n * cached request has been used. If the request has a \"Date\" header, then\r\n * a light weight expiration check is performed and the request will not be\r\n * used immediately.\r\n *\r\n * When using `maxEntries`, the entry least-recently requested will be removed\r\n * from the cache first.\r\n *\r\n * @memberof module:workbox-expiration\r\n */\r\nclass ExpirationPlugin {\r\n    /**\r\n     * @param {Object} config\r\n     * @param {number} [config.maxEntries] The maximum number of entries to cache.\r\n     * Entries used the least will be removed as the maximum is reached.\r\n     * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\r\n     * it's treated as stale and removed.\r\n     * @param {Object} [config.matchOptions] The [`CacheQueryOptions`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/delete#Parameters)\r\n     * that will be used when calling `delete()` on the cache.\r\n     * @param {boolean} [config.purgeOnQuotaError] Whether to opt this cache in to\r\n     * automatic deletion if the available storage quota has been exceeded.\r\n     */\r\n    constructor(config = {}) {\r\n        /**\r\n         * A \"lifecycle\" callback that will be triggered automatically by the\r\n         * `workbox-strategies` handlers when a `Response` is about to be returned\r\n         * from a [Cache](https://developer.mozilla.org/en-US/docs/Web/API/Cache) to\r\n         * the handler. It allows the `Response` to be inspected for freshness and\r\n         * prevents it from being used if the `Response`'s `Date` header value is\r\n         * older than the configured `maxAgeSeconds`.\r\n         *\r\n         * @param {Object} options\r\n         * @param {string} options.cacheName Name of the cache the response is in.\r\n         * @param {Response} options.cachedResponse The `Response` object that's been\r\n         *     read from a cache and whose freshness should be checked.\r\n         * @return {Response} Either the `cachedResponse`, if it's\r\n         *     fresh, or `null` if the `Response` is older than `maxAgeSeconds`.\r\n         *\r\n         * @private\r\n         */\r\n        this.cachedResponseWillBeUsed = async ({ event, request, cacheName, cachedResponse }) => {\r\n            if (!cachedResponse) {\r\n                return null;\r\n            }\r\n            const isFresh = this._isResponseDateFresh(cachedResponse);\r\n            // Expire entries to ensure that even if the expiration date has\r\n            // expired, it'll only be used once.\r\n            const cacheExpiration = this._getCacheExpiration(cacheName);\r\n            dontWaitFor(cacheExpiration.expireEntries());\r\n            // Update the metadata for the request URL to the current timestamp,\r\n            // but don't `await` it as we don't want to block the response.\r\n            const updateTimestampDone = cacheExpiration.updateTimestamp(request.url);\r\n            if (event) {\r\n                try {\r\n                    event.waitUntil(updateTimestampDone);\r\n                }\r\n                catch (error) {\r\n                    if (process.env.NODE_ENV !== 'production') {\r\n                        // The event may not be a fetch event; only log the URL if it is.\r\n                        if ('request' in event) {\r\n                            logger.warn(`Unable to ensure service worker stays alive when ` +\r\n                                `updating cache entry for ` +\r\n                                `'${getFriendlyURL(event.request.url)}'.`);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return isFresh ? cachedResponse : null;\r\n        };\r\n        /**\r\n         * A \"lifecycle\" callback that will be triggered automatically by the\r\n         * `workbox-strategies` handlers when an entry is added to a cache.\r\n         *\r\n         * @param {Object} options\r\n         * @param {string} options.cacheName Name of the cache that was updated.\r\n         * @param {string} options.request The Request for the cached entry.\r\n         *\r\n         * @private\r\n         */\r\n        this.cacheDidUpdate = async ({ cacheName, request }) => {\r\n            if (process.env.NODE_ENV !== 'production') {\r\n                assert.isType(cacheName, 'string', {\r\n                    moduleName: 'workbox-expiration',\r\n                    className: 'Plugin',\r\n                    funcName: 'cacheDidUpdate',\r\n                    paramName: 'cacheName',\r\n                });\r\n                assert.isInstance(request, Request, {\r\n                    moduleName: 'workbox-expiration',\r\n                    className: 'Plugin',\r\n                    funcName: 'cacheDidUpdate',\r\n                    paramName: 'request',\r\n                });\r\n            }\r\n            const cacheExpiration = this._getCacheExpiration(cacheName);\r\n            await cacheExpiration.updateTimestamp(request.url);\r\n            await cacheExpiration.expireEntries();\r\n        };\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            if (!(config.maxEntries || config.maxAgeSeconds)) {\r\n                throw new WorkboxError('max-entries-or-age-required', {\r\n                    moduleName: 'workbox-expiration',\r\n                    className: 'Plugin',\r\n                    funcName: 'constructor',\r\n                });\r\n            }\r\n            if (config.maxEntries) {\r\n                assert.isType(config.maxEntries, 'number', {\r\n                    moduleName: 'workbox-expiration',\r\n                    className: 'Plugin',\r\n                    funcName: 'constructor',\r\n                    paramName: 'config.maxEntries',\r\n                });\r\n            }\r\n            if (config.maxAgeSeconds) {\r\n                assert.isType(config.maxAgeSeconds, 'number', {\r\n                    moduleName: 'workbox-expiration',\r\n                    className: 'Plugin',\r\n                    funcName: 'constructor',\r\n                    paramName: 'config.maxAgeSeconds',\r\n                });\r\n            }\r\n        }\r\n        this._config = config;\r\n        this._maxAgeSeconds = config.maxAgeSeconds;\r\n        this._cacheExpirations = new Map();\r\n        if (config.purgeOnQuotaError) {\r\n            registerQuotaErrorCallback(() => this.deleteCacheAndMetadata());\r\n        }\r\n    }\r\n    /**\r\n     * A simple helper method to return a CacheExpiration instance for a given\r\n     * cache name.\r\n     *\r\n     * @param {string} cacheName\r\n     * @return {CacheExpiration}\r\n     *\r\n     * @private\r\n     */\r\n    _getCacheExpiration(cacheName) {\r\n        if (cacheName === cacheNames.getRuntimeName()) {\r\n            throw new WorkboxError('expire-custom-caches-only');\r\n        }\r\n        let cacheExpiration = this._cacheExpirations.get(cacheName);\r\n        if (!cacheExpiration) {\r\n            cacheExpiration = new CacheExpiration(cacheName, this._config);\r\n            this._cacheExpirations.set(cacheName, cacheExpiration);\r\n        }\r\n        return cacheExpiration;\r\n    }\r\n    /**\r\n     * @param {Response} cachedResponse\r\n     * @return {boolean}\r\n     *\r\n     * @private\r\n     */\r\n    _isResponseDateFresh(cachedResponse) {\r\n        if (!this._maxAgeSeconds) {\r\n            // We aren't expiring by age, so return true, it's fresh\r\n            return true;\r\n        }\r\n        // Check if the 'date' header will suffice a quick expiration check.\r\n        // See https://github.com/GoogleChromeLabs/sw-toolbox/issues/164 for\r\n        // discussion.\r\n        const dateHeaderTimestamp = this._getDateHeaderTimestamp(cachedResponse);\r\n        if (dateHeaderTimestamp === null) {\r\n            // Unable to parse date, so assume it's fresh.\r\n            return true;\r\n        }\r\n        // If we have a valid headerTime, then our response is fresh iff the\r\n        // headerTime plus maxAgeSeconds is greater than the current time.\r\n        const now = Date.now();\r\n        return dateHeaderTimestamp >= now - (this._maxAgeSeconds * 1000);\r\n    }\r\n    /**\r\n     * This method will extract the data header and parse it into a useful\r\n     * value.\r\n     *\r\n     * @param {Response} cachedResponse\r\n     * @return {number|null}\r\n     *\r\n     * @private\r\n     */\r\n    _getDateHeaderTimestamp(cachedResponse) {\r\n        if (!cachedResponse.headers.has('date')) {\r\n            return null;\r\n        }\r\n        const dateHeader = cachedResponse.headers.get('date');\r\n        const parsedDate = new Date(dateHeader);\r\n        const headerTime = parsedDate.getTime();\r\n        // If the Date header was invalid for some reason, parsedDate.getTime()\r\n        // will return NaN.\r\n        if (isNaN(headerTime)) {\r\n            return null;\r\n        }\r\n        return headerTime;\r\n    }\r\n    /**\r\n     * This is a helper method that performs two operations:\r\n     *\r\n     * - Deletes *all* the underlying Cache instances associated with this plugin\r\n     * instance, by calling caches.delete() on your behalf.\r\n     * - Deletes the metadata from IndexedDB used to keep track of expiration\r\n     * details for each Cache instance.\r\n     *\r\n     * When using cache expiration, calling this method is preferable to calling\r\n     * `caches.delete()` directly, since this will ensure that the IndexedDB\r\n     * metadata is also cleanly removed and open IndexedDB instances are deleted.\r\n     *\r\n     * Note that if you're *not* using cache expiration for a given cache, calling\r\n     * `caches.delete()` and passing in the cache's name should be sufficient.\r\n     * There is no Workbox-specific method needed for cleanup in that case.\r\n     */\r\n    async deleteCacheAndMetadata() {\r\n        // Do this one at a time instead of all at once via `Promise.all()` to\r\n        // reduce the chance of inconsistency if a promise rejects.\r\n        for (const [cacheName, cacheExpiration] of this._cacheExpirations) {\r\n            await self.caches.delete(cacheName);\r\n            await cacheExpiration.delete();\r\n        }\r\n        // Reset this._cacheExpirations to its initial state.\r\n        this._cacheExpirations = new Map();\r\n    }\r\n}\r\nexport { ExpirationPlugin };\r\n"],"names":["self","_","e","OBJECT_STORE_NAME","normalizeURL","unNormalizedUrl","url","URL","location","href","hash","CacheTimestampsModel","constructor","cacheName","_cacheName","_db","DBWrapper","onupgradeneeded","event","this","_handleUpgrade","objStore","target","result","createObjectStore","keyPath","createIndex","unique","deleteDatabase","timestamp","entry","id","_getId","put","get","minTimestamp","maxCount","entriesToDelete","transaction","txn","done","request","objectStore","index","openCursor","entriesNotDeletedCount","onsuccess","cursor","value","push","continue","urlsDeleted","delete","CacheExpiration","config","_isRunning","_rerunRequested","_maxEntries","maxEntries","_maxAgeSeconds","maxAgeSeconds","_matchOptions","matchOptions","_timestampModel","Date","now","urlsExpired","expireEntries","cache","caches","open","dontWaitFor","setTimestamp","getTimestamp","Infinity","cachedResponseWillBeUsed","async","cachedResponse","isFresh","_isResponseDateFresh","cacheExpiration","_getCacheExpiration","updateTimestampDone","updateTimestamp","waitUntil","error","cacheDidUpdate","_config","_cacheExpirations","Map","purgeOnQuotaError","registerQuotaErrorCallback","deleteCacheAndMetadata","cacheNames","getRuntimeName","WorkboxError","set","dateHeaderTimestamp","_getDateHeaderTimestamp","headers","has","dateHeader","headerTime","getTime","isNaN"],"mappings":"2FAEA,IACIA,KAAK,6BAA+BC,IAExC,MAAOC,ICKP,MACMC,EAAoB,gBACpBC,EAAgBC,UACZC,EAAM,IAAIC,IAAIF,EAAiBG,SAASC,aAC9CH,EAAII,KAAO,GACJJ,EAAIG,MAOf,MAAME,EAOFC,YAAYC,QACHC,EAAaD,OACbE,EAAM,IAAIC,YArBP,qBAqB0B,EAAG,CACjCC,gBAAkBC,GAAUC,KAAKC,EAAeF,KAUxDE,EAAeF,SAMLG,EALKH,EAAMI,OAAOC,OAKJC,kBAAkBrB,EAAmB,CAAEsB,QAAS,OAIpEJ,EAASK,YAAY,YAAa,YAAa,CAAEC,QAAQ,IACzDN,EAASK,YAAY,YAAa,YAAa,CAAEC,QAAQ,IAGzDC,iBAAeT,KAAKL,sBAQLR,EAAKuB,SAEdC,EAAQ,CACVxB,IAFJA,EAAMF,EAAaE,GAGfuB,UAAAA,EACAhB,UAAWM,KAAKL,EAIhBiB,GAAIZ,KAAKa,EAAO1B,UAEda,KAAKJ,EAAIkB,IAAI9B,EAAmB2B,sBAUvBxB,gBACKa,KAAKJ,EAAImB,IAAI/B,EAAmBgB,KAAKa,EAAO1B,KACnDuB,8BAaGM,EAAcC,SACxBC,QAAwBlB,KAAKJ,EAAIuB,YAAYnC,EAAmB,aAAa,CAACoC,EAAKC,WAE/EC,EADQF,EAAIG,YAAYvC,GACRwC,MAAM,aAAaC,WAAW,KAAM,QACpDP,EAAkB,OACpBQ,EAAyB,EAC7BJ,EAAQK,UAAY,WACVC,EAASN,EAAQlB,UACnBwB,EAAQ,OACFxB,EAASwB,EAAOC,MAGlBzB,EAAOV,YAAcM,KAAKL,IAGrBqB,GAAgBZ,EAAOM,UAAYM,GACnCC,GAAYS,GAA0BT,EASvCC,EAAgBY,KAAKF,EAAOC,OAG5BH,KAGRE,EAAOG,gBAGPV,EAAKH,OAQXc,EAAc,OACf,MAAMrB,KAASO,QACVlB,KAAKJ,EAAIqC,OAAOjD,EAAmB2B,EAAMC,IAC/CoB,EAAYF,KAAKnB,EAAMxB,YAEpB6C,EAUXnB,EAAO1B,UAIIa,KAAKL,EAAa,IAAMV,EAAaE,IC7IpD,MAAM+C,EAcFzC,YAAYC,EAAWyC,EAAS,SACvBC,GAAa,OACbC,GAAkB,OAgClBC,EAAcH,EAAOI,gBACrBC,EAAiBL,EAAOM,mBACxBC,EAAgBP,EAAOQ,kBACvBhD,EAAaD,OACbkD,EAAkB,IAAIpD,EAAqBE,4BAM5CM,KAAKoC,mBACAC,GAAkB,QAGtBD,GAAa,QACZpB,EAAehB,KAAKwC,EACtBK,KAAKC,MAA+B,IAAtB9C,KAAKwC,EAAyB,EAC1CO,QAAoB/C,KAAK4C,EAAgBI,cAAchC,EAAchB,KAAKsC,GAE1EW,QAAcpE,KAAKqE,OAAOC,KAAKnD,KAAKL,OACrC,MAAMR,KAAO4D,QACRE,EAAMhB,OAAO9C,EAAKa,KAAK0C,QAiB5BN,GAAa,EACdpC,KAAKqC,SACAA,GAAkB,EACvBe,cAAYpD,KAAKgD,wCAUH7D,SASZa,KAAK4C,EAAgBS,aAAalE,EAAK0D,KAAKC,0BAanC3D,MACVa,KAAKwC,EASL,cACuBxC,KAAK4C,EAAgBU,aAAanE,GAClC0D,KAAKC,MAA+B,IAAtB9C,KAAKwC,SAJpC,sBAeNH,GAAkB,QACjBrC,KAAK4C,EAAgBI,cAAcO,EAAAA,kDC9HjD,MAYI9D,YAAY0C,EAAS,SAkBZqB,yBAA2BC,OAAS1D,MAAAA,EAAOuB,QAAAA,EAAS5B,UAAAA,EAAWgE,eAAAA,UAC3DA,SACM,WAELC,EAAU3D,KAAK4D,EAAqBF,GAGpCG,EAAkB7D,KAAK8D,EAAoBpE,GACjD0D,cAAYS,EAAgBb,uBAGtBe,EAAsBF,EAAgBG,gBAAgB1C,EAAQnC,QAChEY,MAEIA,EAAMkE,UAAUF,GAEpB,MAAOG,WAWJP,EAAUD,EAAiB,WAYjCS,eAAiBV,OAAS/D,UAAAA,EAAW4B,QAAAA,YAehCuC,EAAkB7D,KAAK8D,EAAoBpE,SAC3CmE,EAAgBG,gBAAgB1C,EAAQnC,WACxC0E,EAAgBb,sBA2BrBoB,EAAUjC,OACVK,EAAiBL,EAAOM,mBACxB4B,EAAoB,IAAIC,IACzBnC,EAAOoC,mBACPC,8BAA2B,IAAMxE,KAAKyE,2BAY9CX,EAAoBpE,MACZA,IAAcgF,aAAWC,uBACnB,IAAIC,eAAa,iCAEvBf,EAAkB7D,KAAKqE,EAAkBtD,IAAIrB,UAC5CmE,IACDA,EAAkB,IAAI3B,EAAgBxC,EAAWM,KAAKoE,QACjDC,EAAkBQ,IAAInF,EAAWmE,IAEnCA,EAQXD,EAAqBF,OACZ1D,KAAKwC,SAEC,QAKLsC,EAAsB9E,KAAK+E,GAAwBrB,MAC7B,OAAxBoB,SAEO,SAKJA,GADKjC,KAAKC,MAC0C,IAAtB9C,KAAKwC,EAW9CuC,GAAwBrB,OACfA,EAAesB,QAAQC,IAAI,eACrB,WAELC,EAAaxB,EAAesB,QAAQjE,IAAI,QAExCoE,EADa,IAAItC,KAAKqC,GACEE,iBAG1BC,MAAMF,GACC,KAEJA,qCAqBF,MAAOzF,EAAWmE,KAAoB7D,KAAKqE,QACtCxF,KAAKqE,OAAOjB,OAAOvC,SACnBmE,EAAgB5B,cAGrBoC,EAAoB,IAAIC"}